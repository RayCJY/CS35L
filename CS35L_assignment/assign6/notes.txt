1. 
To make some change on Makefile, I first implement the Optimization level to debug-friendly optimization.	-->	OPTIMIZE = -Og

2. 
Then add: -Wno-analyzer-possible-null-dereference at the end of CFLAGS. This flag suppresses a specific warning from the Clang Static Analyzer related to possible null pointer dereferences. 
It disables this warning to avoid false positives or when you have specific reasons to ignore it.


3. 
Implement the 'make check' command by adding 'check' function to Makefile.


./randall 100 | wc -c
This test runs the randall program without any specific input or output options, generating 100 random bytes. It checks whether the program generates the expected number of random bytes (100).

./randall -i rdrand 100 | wc -c
This test uses the -i rdrand option to instruct randall to use the rdrand hardware instruction as the source of randomness. It generates 100 random bytes using rdrand and checks whether the program generates the expected number of random bytes (100).

./randall -i mrand48_r 100 | wc -c
This test uses the -i mrand48_r option to instruct randall to use the mrand48_r function as the source of randomness. It generates 100 random bytes using mrand48_r and checks whether the program generates the expected number of random bytes (100).

./randall -i /dev/urandom 100 | wc -c
This test uses the -i /dev/urandom option to instruct randall to use /dev/urandom as the source of randomness.
It generates 100 random bytes from /dev/urandom and checks whether the program generates the expected number of random bytes (100).

./randall -o stdio 100 | wc -c
This test uses the -o stdio option to instruct randall to write the random bytes to the standard output (stdout). It generates 100 random bytes and checks whether the program successfully writes them to stdout.

./randall -o 2 100 | wc -c
This test uses the -o 2 option to instruct randall to write the random bytes to file descriptor 2 (stderr). It generates 100 random bytes and checks whether the program successfully writes them to stderr.


4.
For the file options.c and option.h, I implement them by myself:
Here, leave options.c and options.h blank first, will back to implement them later.

Come back from step 9:
The getOptions function parses command-line options and stores them in the struct opts structure. It handles various error cases and sets the status field to true if valid options are provided. 

The switch statement is used to handle the different options recognized by the program (-i and -o).
For -i (input option):
It checks the value of optarg (the argument associated with the -i option) and sets the options->input field accordingly.
If the input is not recognized, it prints an error message and returns.
For -o (output option):
It checks if the output option is "stdio," and if so, sets options->output to STDOUT.
If the output is not "stdio," it assumes a numeric value as the output size and sets options->output to N and options->size accordingly.
If the size is not a valid numeric value, it prints an error message and returns.

For case ':' and '?', these handle special cases where an option requires an argument (:) or an unrecognized option is encountered (?). In both cases, it prints an error message and returns from the function.


5.
For output.c and output.h, 
I only keep writebytes() function with its related stuff and needed header (#include) for this function.


6.
For rand64-hw.h and rand64-hw.c, 
I put all the hardware implementation part from randall.c into rand64-hw.c.


7.
For rand64-sw.h and rand64-sw.c, 
I put all the software implementation part from randall.c into rand64-sw.c.


8.
Change the 	randall: randall.c to randall: *.c
		$(CC) $(CFLAGS) $*.c -o $@
-->	These can match all .c files in the directory, while randall.c specifically refers to the randall.c source file only. When we run, all files will include


9.
Now, go back to 4 for implement all the options into the options.c.

10.
For the main function:

main Function Definition

int main(int argc, char **argv) {
    struct opts options;
    getOptions(argc, argv, &options);
Starts the main function with argc and argv as arguments. It defines a struct opts to store options and calls getOptions to parse command-line arguments into options.


Error Handling for Command-Line Arguments

    if (!options.status) {
        fprintf(stderr, "%s: Invalid usage. Format: %s NBYTES\n", argv[0], argv[0]);
        return 1;
    }
Checks if the options were correctly parsed. If not, it prints an error message to stderr and returns 1, indicating an error.


Variable Declarations and Initializations

    long long nbytes = options.nbytes;
    if (nbytes == 0)
        return 0;

    void (*initialize)(void) = NULL;
    unsigned long long (*rand64)(void) = NULL;
    void (*finalize)(void) = NULL;

    bool rdrandAvailable = rdrand_supported();
Declares and initializes variables for the number of bytes to process, pointers to functions for initializing, generating, and finalizing random numbers, and checks if hardware-based random number generation (rdrand) is available.


Random Number Generation Setup

    switch (options.input) {
        // Cases for BLANK, RDRAND, MRAND48_R, and SLASH_F
        // Each case sets initialize, rand64, and finalize function pointers
    }
This switch statement sets up the random number generation based on the input method specified in options. It assigns appropriate functions to the function pointers initialize, rand64, and finalize.


Random Number Generation and Output

    initialize();
    int wordsize = sizeof(rand64());
    int output_errno = 0;
Calls the initialize function, determines the size of the random numbers generated, and initializes a variable for storing output errors.


Writing Random Numbers to Standard Output

    if (options.output == STDOUT) {
        // Loop to generate and write random numbers to standard output
        // Error handling and file closure
    }
If output is set to standard output, this block generates random numbers and writes them to stdout. It also handles any errors that occur during writing.


Writing Random Numbers to a Buffer

    else if (options.output == N) {
        // Allocates buffer, generates random numbers, writes to buffer
        // Frees buffer and handles errors
    }
If output is set to a buffer, this block allocates memory for the buffer, generates random numbers, writes them into the buffer, and then writes the buffer to standard output. It also handles memory allocation failure and frees the buffer at the end.


Finalization and Error Handling

    finalize();
    if (output_errno) {
        errno = output_errno;
        perror("Output error");
        return 1;
    }

    return 0;
}
Calls the finalize function to clean up. If there was an output error, it sets errno and prints the error message. The function returns 0 on successful completion or 1 if there was an error.


11. 
bash-4.4$ make randall
gcc -Og -g3 -Wall -Wextra -fanalyzer -march=native -mtune=native -mrdrnd -Wno-a\
nalyzer-possible-null-dereference *.c -o randall


12.
bash-4.4$ make check
if [ `./randall 100 | wc -c` -eq 100 ]; \
then echo "Passed"; \
else echo "Failed"; \
fi;
Passed
if [ `./randall -i rdrand 100 | wc -c` -eq 100 ]; \
then echo "Passed"; \
else echo "Failed"; \
fi;
Passed
if [ `./randall -i mrand48_r 100 | wc -c` -eq 100 ]; \
then echo "Passed"; \
else echo "Failed"; \
fi;
Passed
if [ `./randall -i /dev/urandom 100 | wc -c` -eq 100 ]; \
then echo "Passed"; \
else echo "Failed"; \
fi;
Passed
if [ `./randall -o stdio 100 | wc -c` -eq 100 ]; \
then echo "Passed"; \
else echo "Failed"; \
fi;
Passed
if [ `./randall -o 2 100 | wc -c` -eq 100 ]; \
then echo "Passed"; \
else echo "Failed"; \
fi;
Passed


13.
bash-4.4$ time dd if=/dev/urandom ibs=8192 obs=8192 count=16384 >/dev/null                                                                                                                                                                                                      

16384+0 records in
16384+0 records out
134217728 bytes (134 MB, 128 MiB) copied, 0.941985 s, 142 MB/s

real    0m0.946s
user    0m0.012s
sys     0m0.918s


14.
bash-4.4$ time ./randall 133562368 >/dev/null

real    0m3.145s
user    0m3.118s
sys     0m0.008s
bash-4.4$ time ./randall 133562368 | cat >/dev/null

real    0m3.282s
user    0m3.164s
sys     0m0.264s

bash-4.4$ time ./randall 133562368 >rand.data
real    0m4.745s
user    0m3.111s
sys     0m0.107s

The result shows that /dev/null will faster than other.



15. 
With -i
bash-4.4$ time ./randall -i /dev/urandom 133562368 >/dev/null

real    1m34.924s
user    0m1.938s
sys     1m7.467s
bash-4.4$ time ./randall -i /dev/urandom 133562368 | cat >/dev/null

real    1m35.437s
user    0m1.963s
sys     1m8.091s
bash-4.4$ time ./randall -i /dev/urandom 133562368 >rand.data

real    1m35.053s
user    0m1.903s
sys     1m7.139s

This is the slowest.


16.
With -o
bash-4.4$ time ./randall -o 5 133562368 > /dev/null
real    0m2.737s
user    0m2.679s
sys     0m0.016s
bash-4.4$ time ./randall -o 5 133562368 | cat > /dev/null

real    0m2.731s
user    0m2.640s
sys     0m0.249s
bash-4.4$ time ./randall -o 5 133562368 > rand.data

real    0m4.388s
user    0m2.694s
sys     0m0.141s


17.
Using hardware:
bash-4.4$ time ./randall -i rdrand 133562368 > /dev/null

real    0m3.218s
user    0m3.189s
sys     0m0.008s
bash-4.4$ time ./randall -i rdrand 133562368 | cat > /dev/null

real    0m3.313s
user    0m3.196s
sys     0m0.270s
bash-4.4$ time ./randall -i rdrand 133562368 > rand.data

real    0m4.325s
user    0m3.227s
sys     0m0.099s


18.
mrand48_r from GNU C library
bash-4.4$ time ./randall -i mrand48_r 133562368 > /dev/null

real    0m0.730s
user    0m0.705s
sys     0m0.011s
bash-4.4$ time ./randall -i mrand48_r 133562368 | cat > /dev/null

real    0m0.865s
user    0m0.758s
sys     0m0.274s
bash-4.4$ time ./randall -i mrand48_r 133562368 > rand.data

real    0m2.401s
user    0m0.709s
sys     0m0.134s










